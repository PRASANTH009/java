#!/usr/bin/env groovy
def app
pipeline {
  agent any
  //All parameters which will be used to run the pipeline.
  parameters {
		string(name: 'DOCKERHUB_URL', defaultValue: '', description: 'Dockerhub Url')
        string(name: 'DOCKERHUB_CREDETIAL_ID', defaultValue: 'DockerCred', description: 'Dockerhub CredentialId')
		string(name: 'GIT_CREDETIAL_ID', defaultValue: '8c6a9d0e-492a-4ee4-ac03-2e88e3a8c9a7', description: 'Github CredentialId')
		string(name: 'DOCKER_IMAGE_NAME', defaultValue: '', description: 'Docker Image Name')
		string(name: 'DOCKER_TAG', defaultValue: '', description: 'Docker Image Tag')
		string(name: 'GIT_URL', defaultValue: 'https://github.com/PRASANTH009/node-js-sample.git', description: 'Git Url')
		string(name: 'SONARQUBE_URL', defaultValue: 'http://ec2-54-156-240-215.compute-1.amazonaws.com:9000/', description: 'SonarQube Url')
		string(name: 'SONARQUBE_PROJECT_NAME', defaultValue: 'Node-Test-101', description: 'SonarQube Project Name')
		
		string(name: 'JFROG_CREDENTIALID', defaultValue: 'JfrogId', description: 'JFrog repository password')
		string(name: 'JFROG_URL', defaultValue: 'http://ec2-34-238-216-133.compute-1.amazonaws.com:8081/artifactory/Pipeline-Test-Repo/', description: 'JFrog repository URL')
		}
  stages {
    stage('Collect the parameters') {
      steps { 
         
         sh 'ls -al'
                  sh '''echo "FROM node:9

# Create app directory
WORKDIR /app/server

LABEL maintainer="ITC-Spadelite-Team"

RUN npm install -g grunt 
RUN npm install -g express
RUN npm install -g forever
RUN npm install -g mocha
RUN npm install supertest --save-dev

EXPOSE 6000

" >> Dockerfile'''

         
      }
      
    }
    stage('Build Docker Image'){
        steps{
            script{
                app = docker.build("${params.DOCKER_IMAGE_NAME}/${params.DOCKER_TAG}")
                //sh 'docker images'
                //cleanup()
               // cleanWs()
            }
            
        }
        post  {
            failure{
                script{
			// If there was an exception thrown, the build failed.
			currentBuild.result = "FAILED"
			notifyFailedBuild('Build image')
			cleanup()
					}
            }
        }
    }
    stage('push image to Hub'){
        steps{
            script{
                echo "${app}"
                docker.withRegistry("${params.DOCKERHUB_URL}", "${params.DOCKERHUB_CREDETIAL_ID}") {
                app.push("${env.BUILD_NUMBER}")//tag the image with the current build no.
                app.push("${params.DOCKER_TAG}") // tag the image with the param tag
			}
            }
        }
             post {
                 failure{
                     script{
			// If there was an exception thrown, the build failed
			currentBuild.result = "FAILED"
			notifyFailedBuild('Push image')
			cleanup()
                 }
                 }
			
			}
            
        
    }
   stage('Create Bridge') {
       steps{
			sh """
			docker network create --driver bridge spadelite${env.BUILD_NUMBER}
			"""
			}
			post {
			    failure{ 
			        script{
			        
			// If there was an exception thrown, the build failed
			currentBuild.result = "FAILED"
			notifyFailedBuild('Create Bridge')
			cleanup()
			
			}
			}
			}
   }

	stage('pulling docker image'){
	    agent{
	        docker{
	            image "${params.DOCKER_IMAGE_NAME}/${params.DOCKER_TAG}"
	             registryCredentialsId "${params.DOCKERHUB_CREDETIAL_ID}"
	            registryUrl "${params.DOCKERHUB_URL}"
	            args  "--net spadelite${env.BUILD_NUMBER} -u root -d --publish 6000:6000"
	            
	        }
	    }
	    
	    stages{
	        	stage('Scm checkout'){
	    
	    steps{
	        checkout(	[$class                          : 'GitSCM',
				  branches                         : [[name: '*/master']],
				  doGenerateSubmoduleConfigurations: false,
				  extensions                       : [],
				  submoduleCfg                     : [],
				  userRemoteConfigs                : [[credentialsId: "${params.GIT_CREDETIAL_ID}",
				  url          					   : "${params.GIT_URL}"]]])
				  sh 'pwd'
	    }
	     post {
	         failure{
	             script{
			// If there was an exception thrown, the build failed
			currentBuild.result = "FAILED"
			notifyFailedBuild('Checkout code')
			cleanup()
	             }
			
			}
	     }
	     
			 
	}
	        stage('Build NPM'){
	            steps{
    	       sh 'pwd'
    	        sh 'ls -al'
    	        sh '''npm install -g #Build the code using NPM			
                      npm install sonarqube-scanner --save-dev #install sonarqube-scanner'''
	              }
	               post {
	                   failure{ 
	                       script{
			// If there was an exception thrown, the build failed
			currentBuild.result = "FAILED"
			notifyFailedBuild('Build NPM')
			cleanup()
	                   }
	                   }
			}
	        }
	         stage('Sonar Analysis'){
	             steps{
	withSonarQubeEnv('sonarqube') {
			 sh """
			 
			 
			 #create the temporary .js file to execute the sonar scan.
			 cat > sonar-project.js <<- "EOF"
			 const sonarqubeScanner = require('sonarqube-scanner');
			 sonarqubeScanner({
			 serverUrl: "${params.SONARQUBE_URL}",// Sonar server url param
			 options : {
			'sonar.sources': '.',
			'sonar.projectName': "${params.SONARQUBE_PROJECT_NAME}", //Name of the project which will be created in the Sonar server
			}
			}, () => {});
			EOF
			
			node sonar-project.js //execute the sonar scan
			rm sonar-project.js   #remove the temporary file. 
			""" 
			 }
			 /* timeout(time: 1, unit: 'HOURS') {
                waitForQualityGate abortPipeline: true
              }*/
			 }
			 post {
			     failure{
			         script{
			// If there was an exception thrown, the build failed
			currentBuild.result = "FAILED"
			notifyFailedBuild('Sonar Analysis')
			cleanup()
			     }
			     }
			}
	         }
	         
	    stage('Unit testing using mocha'){
			 steps{
			        sh 'ls -al'
			 sh '''npm install supertest --save-dev
                         #mocha tests/test.js --reporter spec '''
                         sh 'ls -al'
 
			 }
			 post {
			     failure{
			         script{
			// If there was an exception thrown, the build failed
			currentBuild.result = "FAILED"
			notifyFailedBuild('Unit testing using mocha')
			cleanup()
			     }
			     }
			 }
			
			 }   
			 
			  stage('Push artifacts to Artifactory'){
			      steps{
			
			withCredentials([usernamePassword(credentialsId: 'JfrogId',
                     usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
    
               sh """
			touch ${env.JOB_NAME}${env.BUILD_NUMBER}.tar.gz
			tar --exclude='./node_modules' --exclude='./.scannerwork' --exclude='./.git' --exclude='./.gitignore' --exclude=${env.JOB_NAME}${env.BUILD_NUMBER}.tar.gz -zcvf ${env.JOB_NAME}${env.BUILD_NUMBER}.tar.gz .
			curl -u $USERNAME:$PASSWORD -X PUT "${params.JFROG_URL}" -T "./${env.JOB_NAME}${env.BUILD_NUMBER}.tar.gz"
			"""

         }
          notifySuccessBuild()
			      }
		
			
			post {
			    failure{
			        script{
			// If there was an exception thrown, the build failed
			currentBuild.result = "FAILED"
			notifyFailedBuild('Push artifacts to Artifactory')
			cleanup()
			    }
			}
			} 
			
			
			 }
			  }
	         
	    }
	    
	    
	
		
}
    post { 
        always { 
		    cleanup()  //perform clean up
            cleanWs() //cleanup workspace
        }
		
    }
  
 
}
   
   // function to handle the failed build notification.
		def notifyFailedBuild(String stage) {
		
		emailext(
		  to: "Samadimuni.Yadav@itcinfotech.com",
		  subject: "Build Failed: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'",
		  body: "This email is to notify that Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' has been failed. Failed stage: [${stage}]"
		)
		}
		
	// function to handle successful build notification.
		def notifySuccessBuild() {
		
		emailext(
		  to: "Samadimuni.Yadav@itcinfotech.com",
		  subject: "Build Success: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]'",
		  body: "This email is to notify that Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' has been completed successfully"
		)
		}
//function to clean docker container, volumes and network		
		def cleanup() {
		sh """
		docker ps -q -f status=exited | xargs --no-run-if-empty docker rm
		docker images -q -f dangling=true | xargs --no-run-if-empty docker rmi
		docker volume ls -qf dangling=true | xargs -r docker volume rm
		docker network rm spadelite${env.BUILD_NUMBER}
		"""
		}	
